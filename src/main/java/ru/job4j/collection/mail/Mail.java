package ru.job4j.collection.mail;


import java.util.*;

public class Mail {

    /**
     * Этот метод принимает список пользователей, каждому из которых соответствует
     * множество электронных адресов почт. Если у разных пользователей, есть одинаковые
     * адреса почт, то они объединяются, считается, что это один и тот же полоьзователь.
     * Ему присваивается имя одного из обьъединённых пользователей.
     * В Данном методе в качестве промежуточного результата используется карта.
     * В неё записывается в качестве ключа пользователь, множество которого мы перенесли(он
     * не будет фигурировать в финальном списке), а в качестве значения - пользователь,
     * в множество которого мы его перенесли(Он будет в финальном списке).
     * То есть, пара ключ-значение представляет из себя пару двух объединённых пользователей.
     * Либо, если добавленный пользователь ни с кем не объединялся (или к нему скопированы значения
     * другого, а он сам будет в результирющем списке), то ключ и значение будут равны.
     * Делается это для того, чтобы в случае необходимости объединения третьего пользователя с
     * пользователем - ключом(который уже с кем-то объединён), мы перенесли его множество почт сразу
     * в пользователя-значение(который будет в результирующем списке).
     * Затем из карты извлекаются значения в множество, чтобы избежать повторов, и возвращается
     * список на основании этого множества.
     * @param list список пользователей
     * @return новый списаок пользователей, в котором пользователи, имеющие хотя бы одно
     * совпадение по адресам электронных почт, объединены
     */
    public List<User> mergeUsers(List<User> list) {
        Map<Email, List<User>> map = usersForEachMail(list);
        Map<User, User> rsl = new HashMap<>();
        for (Map.Entry<Email, List<User>> pairs : map.entrySet()) {
            List<User> users = pairs.getValue();
            User firstInList = users.get(0);
            if (!rsl.containsKey(firstInList)) {
                rsl.put(firstInList, firstInList);
            } else {
                firstInList = rsl.get(firstInList);
            }
            for (int i = 1; i < users.size(); i++) {
                firstInList.getMailSet().addAll(users.get(i).getMailSet());
                rsl.put(users.get(i), firstInList);
            }
        }
        return new ArrayList<>(new HashSet<>(rsl.values()));
    }

    /**
     * Этот метод принимает на вход список пользователей, у которых есть в качестве
     * поля множество почт. Он добавляет каждую почту из всех множеств
     * в качестве ключа в карту. В качечстве значения - список пользователей,
     * у которых данная почта хранится. Важно, что в качестве возвращаемого
     * значения используется имеенно упорядоченная в порядке добавлению карта, т.к.
     * в дальнейшем надо будет перебирать значения карты именно в порядке добавления
     * для правильной работы программы.
     * @param list список пользователей
     * @return карта, содержащая почту вкачестве ключа и список пользователей,
     * хранящих данную почту, в качестве значения
     */
    private Map<Email, List<User>> usersForEachMail(List<User> list) {
        Map<Email, List<User>> rsl = new LinkedHashMap<>();
        for (User user : list) {
            for (Email mails : user.getMailSet()) {
                if (rsl.containsKey(mails)) {
                    rsl.get(mails).add(user);
                } else {
                    List<User> inMap = new ArrayList<>(list.size());
                    inMap.add(user);
                    rsl.put(mails, inMap);
                }
            }
        }
        return rsl;
    }
}



